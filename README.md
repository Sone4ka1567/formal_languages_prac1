# Практическое задание №1. Формальные языки и трансляции.


<b>Условие</b>

Даны α и натуральные числа k, l, такие что 0 <= l < k. Вывести минимальное
число n, равное l по модулю k, такое что L содержит слова длины n.

<b>Решение</b>

Буду использовать динамику для решения данной задачи. Заметим, что мне дан остаток числа от деления на k, то есть задача - найти целую часть.
Также регулярка дана в обратной польской записи. Это наталкивает на мысль написать динамику:

Для каждого регулярного выражения заведем list из k элементов(ибо у нас k возможных остатков). В i-том элементе храним наим возможную целую часть от деления n на k с остатком i, такое что
слово с длиной n у нас есть в данной регулярке.(или если такого нет то -1)

<b>База:</b> 
Для пустого слова list будет состоять из 0 под индексом 0 и остальных -1, ибо для регулярки = пустому слову 0*k + 0 = 0, а слово длины 0 ей как раз принадлежит

Буквы у нас отождествляются и для каждой буквы list будет состоять из 0 под индексом 1 и остальных -1 (достаточно провести аналогичные рассуждения)

<b>Переход по операциям</b>

1) Если у нас операция + (то есть или одно, или другое) то так как в каждом list мы храним минимумы, то достаточно для результирующей регулярки для каждого индекса положить минимум
   из двух соответствующих значений исходных регулярок (при условии что они определены), если определена лишь одна, то положить вторую, если обе не определены то и результат не определен.
   
2) Если идет конкатенация, то каждый остаток по модулю можно получить несколькими способами, сложив некоторые остатки исходных регулярок. 
   Заведем list, где всем элементам присвоим какое-то недостигаемое значение, большее всех возможных, переберем все возможные пары элементов исходных регулярок.
   (expr1[i] + i) + (expr2[j] + j) будет кандидатом для result[i + j]. Выбираем минимальное значение, при условии что соотв. элементы исходных регулярок определены.
   В итоге если что-то осталось неопределено, значит мы никогда не обновляли этот элемент, значит те элементы result, которые остались равны какому-то недостигаемому значению меняем на -1
   
3) Звезда Клини - это конкатенация выражения мамим с собой бесконечность раз ( плюс пустое слово!!!!!!). Однако, если учесть, что нас интересуют длины слов по модулю k, то не имеет смысла делать конкатенацию больше k раз
   (всё тупо поделится по модулю). Тогда делаем конкатенацию k раз, не забываем про пустое слово а также надо учесть, что в результате может находиться регулярка из меньшего количества конкатенаций. Однако мы уже учли это, когда
   в исходной регулярке поставили 0 под индексом 0, делая его в какой-то степени эквивалентным пустому слову.
   

<b>Ответ</b>
Ответ в силу хорошего выбора динамики будет прост - он лежит в list[l]. Осталось только проверить, что это не -1 и не забыть прибавить l (опять же в листе лежит мин целая часть)
Если же вдруг элемент равен -1, то мы не нашли в регулярке слово подходящей длины и надо вывести INF


<b>Парсинг</b>
Дело за малым - распарсить регулярку. Это делается с помощью стэка, куда мы кладем буквы и результаты выражений, если встречаем операцию - вытаскиваем нужное колво элементов со стека и делаем динамику.
Надо не забыть кидать исключения, если вдруг дана плохая по формату регулярка, а именно - символы не из алфавита, неправильная запись и тд (все константные символы вынесены в отдельный файлик, чтоб их было проще менять)))

<b>Асимптотика</b>

Пусть N - длина регулярки. Считывание символов происходит за O(1), разберемся с операциями:

1) сложение - O(k)
2) конкатенация - O(K^2)
3) звезда Клини - O(k * k^2) = O(k^3)

Теперь заметим, что операций сложения и конкатенации у нас возможно не более чем O(N) каждой, ибо для каждой из этих операций необходимо 2 аргумента(+ она сама)
Звезд клини же у нас не более чем O(N)

Тогда суммарно получается полиномиальная сложность
